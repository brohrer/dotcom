<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="description" content="HTTYR home">
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">

    <base target="_blank">
    <title>How to Train Your Robot</title>
    </head>

    <body>
      <!-- HEADER -->
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            How to Train Your Robot
          </h1>
          <h4>
            <a href="https://brandonrohrer.com">Brandon Rohrer</a>
          </h4>
        </header>
      </div>

      <!-- MAIN CONTENT -->
      <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">
          <p>
            How to Train Your Robot is a long term side project.
            I've been working on it in some form for 20 years.
            My lifetime goal is to make a robot as smart as my pup.
            It's a long road, but it has a lot of fascinating stops like
            machine learning, Python development, software engineering,
            and robotics. Come join me.
          </p>

          <a href="https://tyr.fyi/1">
            <h4>Chapter 1: Can't AI Already Do That?</h4></a>

          <a href="https://tyr.fyi/2">
            <h4>Chapter 2: Keeping Time with Python</h4></a>

          <a href="https://tyr.fyi/3">
            <h4>Chapter 3: Getting Processes to Talk to Each Other</h4></a>

          <a href="https://tyr.fyi/4">
            <h4>Chapter 4: Making Animations with Matplotlib</h4></a>

          <a href="https://tyr.fyi/5">
            <h4>Chapter 5: Simulating the Physical World</h4></a>

          <a href="https://tyr.fyi/6">
            <h4>Chapter 6: Making Your Python Code Run Faster</h4></a>

          <a href="https://tyr.fyi/7">
            <h4>[In progress] Chapter 7: Would You Like to Play a Game?</h4></a>

          <a href="https://tyr.fyi/8">
            <h4>[In progress] Chapter 8: Deconstructing Sound</h4></a>

          <a href="https://brandonrohrer.com/ziptie">
            <h4>Chapter 9: Ziptie: Learning Useful Features</h4></a>

          <a href="https://tyr.fyi/10">
            <h4>[In progress] Chapter 10: Reconstructing Sound</h4></a>

          <a href="https://brandonrohrer.com/cartographer">
            <h4>Chapter 11: Naive Cartographer: A Markov Decision Process Learner</h4></a>

          <a href="https://codeberg.org/brohrer/myrtle/projects">
            <h4>[In progress] Chapter 12: Myrtle: A Benchmarking Framework for Reinforcement Learning</h4></a>

          <a href="https://tyr.fyi/13">
            <h4>[In progress] Chapter 13: A Dead Simple Message Queue</h4></a>

          <hr>
          <hr>

          <a href="https://tyr.fyi/1">
            <h4>Chapter 1: Can't AI Already Do That?</h4></a>

          <ul>
            <li>
              5. AI is still not as smart as my Shih Tzu.
            </li>
            <li>
              8. Unsupervised learning 
            </li>
            <li>
              13. Supervised learning
            </li>
            <li>
              18. Reinforcement learning
            </li>
            <li>
              19. Rewards
            </li>
            <li>
              20. Labels
            </li>
            <li>
              24. Reward engineering
            </li>
            <li>
              28. Human-Directed Reinforcement Learning (HDRL)
            </li>
            <li>
              31. Sample efficiency
            </li>
          </ul>

          <a href="https://tyr.fyi/2">
            <h4>Chapter 2: Keeping Time with Python</h4></a>
          <ul>
            <li>
              5. The wall clock
            </li>
            <li>
              8. Measuring time
            </li>
            <li>
              17. Python
            </li>
            <li>
              19. Platform (in)dependence
            </li>
            <li>
              21. time.time()
            </li>
            <li>
              25. Timing code
            </li>
            <li>
              35. time.sleep()
            </li>
            <li>
              42. Pacing code
            </li>
            <li>
              48. The Pacemaker class
            </li>
          </ul>

          <a href="https://tyr.fyi/3">
            <h4>Chapter 3: Getting Processes to Talk to Each Other</h4></a>
          <ul>
            <li>
              6. Why muliple processes? 
            </li>
            <li>
              8. Why not threads?
            </li>
            <li>
              10. Case study: Counting people
            </li>
            <li>
              11.The getkey package
            </li>
            <li>
              14. Python environment management
            </li>
            <li>
              16. Getting keypresses
            </li>
            <li>
              21. multiprocessing.Queue
            </li>
            <li>
              27. Connecting processes with a Queue
            </li>
            <li>
              33. Logging
            </li>
            <li>
              34. Over-engineering vs under-engineering
            </li>
            <li>
              42. Logging with JSON
            </li>
            <li>
              53. Linting with flake8 and autoformatting with black
            </li>
            <li>
              60. Reporting 
            </li>
            <li>
              69. Shell scripting
            </li>
          </ul>

          <a href="https://tyr.fyi/4">
            <h4>Chapter 4: Making Animations with Matplotlib</h4></a>
          <ul>
            <li>
              5. Case Study: Lissajous oscillations     
            </li>
            <li>
              8. Animation and robotics 
            </li>
            <li>
              9. Frame rate
            </li>
            <li>
              12. Matplotlib
            </li>
            <li>
              13. Object-Oriented Programming
            </li>
            <li>
              20. Drawing with Matplotlib
            </li>
            <li>
              22. Animation with Matplotlib
            </li>
            <li>
              26. Colors   
            </li>
            <li>
              29. Order and depth
            </li>
            <li>
              36. Patches
            </li>
            <li>
              41. Translation
            </li>
            <li>
              44. Scaling
            </li>
            <li>
              45. Anchors
            </li>
            <li>
              51. Rotation
            </li>
            <li>
              61. Point to point movement  
            </li>
            <li>
              69. Minimum-jerk speed profiles
            </li>
            <li>
              74. Logit-normal speed profiles
            </li>
          </ul>

          <a href="https://tyr.fyi/5">
            <h4>Chapter 5: Simulating the Physical World</h4></a>
          <ul>
            <li>
              6. Case study: Tetris shapes 
            </li>
            <li>
              7. Force = mass x acceleration
            </li>
            <li>
              10. Numerical differentiation
            </li>
            <li>
              14. Numerical integration
            </li>
            <li>
              21. Separate processes for simulation and animation
            </li>
            <li>
              26. Platform (in)dependence
            </li>
            <li>
              32. Modeling atom-to-atom contact
            </li>
            <li>
              39. Modeling atom-to-wall contact
            </li>
            <li>
              45. Pitfalls of time discretization
            </li>
            <li>
              48. Correcting for time discretization
            </li>
            <li>
              53. Friction and inelasticity
            </li>
            <li>
              60. Objects that are not circles
            </li>
            <li>
              70. Stationary features
            </li>
            <li>
              72. Initializating objects
            </li>

          </ul>

          <a href="https://tyr.fyi/6">
            <h4>Chapter 6: Making Your Python Code Run Faster</h4></a>
          <ul>
            <li>
              4. When to optimize
            </li>
            <li>
              9. Profiling
            </li>
            <li>
              10. py-spy
            </li>
            <li>
              14. Vectorization
            </li>
            <li>
              23. Numba
            </li>
            <li>
              28. For-loops in Numba
            </li>
            <li>
              29. @jit and @njit
            </li>
            <li>
              31. Types
            </li>
            <li>
              34. Preallocation
            </li>
            <li>
              36. Incremental development
            </li>
            <li>
              37. Matrix multiplication
            </li>
            <li>
              39. The Ten Suggestions for working with Numba
            </li>
            <li>
              43. Other optimzation methods
            </li>
            <li>
              45. Monitoring
            </li>
            <li>
              46. Choosing a metric  
            </li>
            <li>
              49. Aggregate metrics
            </li>
            <li>
              52. A separate monitoring process
            </li>
            <li>
              57. The Dashboard
            </li>
            <li>
              63. Robust multi-process shutdown
            </li>

          </ul>

        </section>
      </div>
    </body>
  </head>
</html)
