 <?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">

<channel>
  <title>Brandon Rohrer</title>
  <link>https://www.brandonrohrer.com</link>
  <image>
    <url>http://e2eml.school/images/transformers/architecture_multihead.png</url>
    <title>Blog</title>
    <link>https://www.e2eml.school</link>
  </image>
  <description>Brandon Rohrer's blog, articles, and books</description>

  <item>
    <title>Naive Cartographer: A Markov Decision Process Learner</title>
    <link>https://codeberg.org/brohrer/cartographer-paper/raw/branch/main/cartographer.pdf</link>
   <description>
   tl;dr: A naive Bayes algorithm for learning Markov de-
cision processes with fuzzy state

x Fuzzy Naive Cartographer (FNC) builds a Markov Decision Process-like model of
its world in the form of a set of sequences. Sequences are of the form of
state-action-state as in MDPs. Here they're also referred to as
feature-action-outcome sequences, to disambiguate the before- and after-state.

FNC builds a value function too. It creates a set of feature-action pairs
and associates a reward with each. This is analogous to the state-action
value functions of Q-learning.

A model and a value function allow for prediction and planning.
Knowing the current active features and recent actions,
both the reward and the resulting features can be anticipated.

Technically FNC is just the "model" part of a model-based RL algorithm.
It needs to paired with a planner, some element that will choose
an action or goal, to be a complete RL algorithm.
There are some rudimentary planners included with this module to get you up and running.

Repository: https://codeberg.org/brohrer/ziptie

White paper: https://codeberg.org/brohrer/cartographer-paper/raw/branch/main/cartographer.pdf
</description>
  </item>

  <item>
    <title>Ziptie, byte pair encoding for fuzzy variables</title>
    <link>https://www.brandonrohrer.com/ziptie</link>
   <description>
   A robot learning to navigate the world finds that the combination of
   certain sensors gives more information than either
of them alone. The combination of x- and y-position tells
more about when to watch for obstacles than either variable
on its own. The speed and position of arm tells more about
what shoulder torque needs to be generated than either does
alone. Individual pixels from a camera are of very little use,
but certain patterns are detected across many pixels, they
can clearly distinguish between a hawk and a handsaw.

These cases of sensor interaction can be hard coded manually.
Human designers often exploit their knowledge of the
system to do this via feature engineering, but in cases where
the robot system is too complex to intuit these useful interactions,
they can be learned. Automatically creating these
predictive features is the goal of the Ziptie algorithm.

Repository: https://codeberg.org/brohrer/ziptie

White paper: https://codeberg.org/brohrer/ziptie-paper/raw/branch/main/ziptie.pdf 
</description>
  </item>

  <item>
    <title>sqlogging, a sqlite3-based logging library for Python</title>
    <link> https://github.com/brohrer/sqlogging </link>
    <description>I wrote some code!

sqlogging roughly mimics Python’s logging library except that it writes log
entries as rows of a sqlite table. It’s not fast
(about 7 ms per write on my machine) but if you spend time working with your log
data the improved flexibility is life changing. No tedious json parsing,
no fiddly pandas syntax. Just SQL to base Python. 

Nothing feels quite as satisfying as making something useful. 

If you want to try it, it’s pip installable.

pip install sqlite-logging

And in proactice it looks like this:

from sqlogging import logging

logger = logging.create_logger(name="test_logger", columns=["iter", "score"])

logger.info({"iter": 0, "score": .4})

logger.info({"iter": 1, "score": .1})

logger.info({"iter": 2, "score": .8})

result = logger.query(f"SELECT SUM(score) FROM {logger.name}")

print("sum of scores:", result[0][0])

logger.delete()
</description>
  </item>

  <item>
    <title>pacemaker, a metronome for your Python code</title>
    <link> https://github.com/brohrer/pacemaker </link>
    <description>
A carefully paced loop comes in handy for interacting with physical sensors and robots, managing rate-limited APIs, synchronizing frame refreshes in animations, and pacing cycles in real-time simulations. Pacemaker provides an accurate metronome for your code to keep time with, good up to 1 MHz.

The pacemaker package is intentionally minimalistic and has no external dependencies. It's a glorified snippet. I kept dragging it from project to project, so I finally decided to turn it into an actual package. Works on Linux, Windows, and MacOS.

the repo: https://github.com/brohrer/pacemaker

the long-winded explanation of how it does what it does: https://brandonrohrer.com/httyr2pdf

Installation

pip install pacemaker-lite

Usage

from pacemaker.pacemaker import Pacemaker

iterations_per_second = 2.5

pm = Pacemaker(iterations_per_second)

for i in range(100):

    _ = pm.beat()

    print(i)
</description>
  </item>

  <item>
    <title>From csv to database with Python</title>
    <link> https://e2eml.school/db_penguins.html </link>
    <description> Databases are the new Dataframes

Not really, but join me in a thought experiment.

Imagine you wanted to do some data analysis, but also wanted to avoid importing any external libraries into Python. This is not just an academic exercise. A large part of the challenge of working in Python is managing dependencies, environments, and breaking updates. Sticking with base Python and the libraries it ships with would make your code considerably more robust and lower maintenance.

We can do exactly this with SQLite3. To demonstrate how we would ingest a csv to a Dataframe will use the most excellent Palmer Penguins Data Set.
</description>
  </item>

  <item>
    <title>A Pythonista's First Database</title>
    <link>https://e2eml.school/db_first_db.html </link>
    <description> It's a familiar story. Your friends all brag about their humongous databases. They go on and on about MySQL this and Redis that, and "oh can you believe they swapped out Mongo for Snowflake!?!" and they all laugh and you pretend to laugh along. But inside you're sad because you don't have a database. Well today is your lucky day. Today you get a database of your very own.

One of the sleekest and slickest databases out there is SQLite. It's so lean that it got folded right into standard Python as the sqlite3 library. It's the single most used database in the world, and its code is entirely open source, in the public domain.

If you're already working in Python, you have SQLite installed. </description>
  </item>

  <item>
    <title>Navigating Database Awkwardness: The First Date</title>
    <link>https://e2eml.school/db_awkwardness.html </link>
    <description> One of the things that can make databases awkward at first, especially in Python, is the terminology. It’s based on some old school concepts and technologies. A very long time ago bits were carved into stone tablets with magnetic chisels. These tablets were circular in shape and stacked on top of each other, resulting in something shaped like a can, or a drum. And this is why databases are always represented as cylinders in architecture diagrams.</description>
  </item>

  <item>
    <title>How to Train Your Robot has a Table of Contents</title>
    <link>https://tyr.fyi</link>
    <enclosure url="https://www.brandonrohrer.com/feed/tyr_toc.png" length="107110" type="image/png" />
    <description>The book project now has enough content to merit a table of contents.</description>
  </item>

  <item>
    <title>Making Your Python Code Run Faster: How to Train Your Robot, Chapter 6</title>
    <link>https://tyr.fyi/6</link>
    <enclosure url="https://www.brandonrohrer.com/feed/numba_ten.png" length="89931" type="image/png" />
    <description>Chapter six is all about getting code to do what you want faster. It's hard keeping up with the wall clock. Luckily profilers, vectorization, and Numba are there for us.</description>
  </item>

  <item>
    <title>Simulating the Physical World: How to Train Your Robot, Chapter 5</title>
    <link>https://tyr.fyi/5</link>
    <enclosure url="https://www.brandonrohrer.com/feed/tetris.png" length="50606" type="image/png" />
    <description>In chapter five we take a detailed look at turning the physics of rigid bodies into fast Python code.</description>
  </item>

  <item>
    <title>Making Animations with Matplotlib: How to Train Your Robot, Chapter 4</title>
    <link>https://tyr.fyi/4</link>
    <enclosure url="https://www.brandonrohrer.com/feed/spaceship.png" length="68666" type="image/png" />
    <description>Chapter four is all about how to make moving pictures.  It's entertaining, yes, but it's also a very good way to represent complex data that changes over time. It also happens to be a great companion to games and simulations, which is exactly how we'll be using it a few chapters later.</description>
  </item>

  <item>
    <title>Getting Processes to Talk to Each Other: How to Train Your Robot, Chapter 3</title>
    <link>https://tyr.fyi/3</link>
    <enclosure url="https://www.brandonrohrer.com/feed/queue.png" length="54305" type="image/png" />
    <description>In this chapter we get to build an adding machine. It is exactly as fascinating as it sounds.</description>
  </item>

  <item>
    <title>Keeping Time with Python: How to Train Your Robot, Chapter 2</title>
    <link>https://tyr.fyi/2</link>
    <enclosure url="https://www.brandonrohrer.com/feed/sleep.png" length="367523" type="image/png" />
    <description>The second installment in a quest to build a robot as smart as my pup.</description>
  </item>

  <item>
    <title>How to Train Your Robot, Chapter 1</title>
    <link>https://tyr.fyi/1</link>
    <enclosure url="https://www.brandonrohrer.com/feed/ducks.png" length="725898" type="image/png" />
    <description>The first chapter of a book that builds a solution to the Human Directed Reinforcement Learning (HDRL) problem, more commonly known as teaching a dog to sit.  It's titled Can't Artificial Intelligence Already Do That</description>
  </item>

  <item>
    <title>Transformers From Scratch</title>
    <link>https://e2eml.school/transformers</link>
    <enclosure url="https://e2eml.school/images/transformers/architecture_multihead.png" length="108278" type="image/png" />
    <description>A step-by-step walkthrough of transformers,
      the algorithm behind Large Language Models like ChatGPT.</description>
  </item>

  <item>
    <title>Homepage</title>
    <link>https://e2eml.school</link>
    <description>A list of what I've written.</description>
  </item>

</channel>

</rss> 
